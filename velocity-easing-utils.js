// Generated by CoffeeScript 1.10.0
var VelocityEasingUtils,
  slice = [].slice;

VelocityEasingUtils = {
  _inverseEasing: function(easing) {
    return function(progress) {
      var hi, lo, mid;
      if (progress === 0) {
        return 0;
      }
      if (progress === 1) {
        return 1;
      }
      lo = 0;
      hi = 1;
      while (hi - lo > 1e-6) {
        mid = (lo + hi) / 2;
        if (easing(mid) < progress) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
      return lo;
    };
  },
  _renormalizedEasing: function(easing, fromDuration, toDuration) {
    var fromProgress, toProgress;
    fromProgress = easing(fromDuration);
    toProgress = easing(toDuration);
    return function(itemTime) {
      var itemProgress, sequenceProgress, sequenceTime;
      sequenceTime = (itemTime * (toDuration - fromDuration)) + fromDuration;
      sequenceProgress = easing(sequenceTime);
      itemProgress = (sequenceProgress - fromProgress) / (toProgress - fromProgress);
      return itemProgress;
    };
  },
  _composeEasing: function(easing1, easing2) {
    return function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return easing1(easing2.apply(null, args));
    };
  },
  _getDuration: function(item) {
    var options;
    options = item.o || item.options || $.Velocity.defaults;
    if ('duration' in options) {
      return options.duration;
    } else {
      return $.Velocity.defaults.duration;
    }
  },
  sequenceWithOptions: function(sequence, arg) {
    var cumulativeWeight, debugCanvas, duration, easing, easingFunc, totalWeight;
    easing = arg.easing, duration = arg.duration, debugCanvas = arg.debugCanvas;
    console.assert(easing);
    console.assert(easing in $.Velocity.Easings, "String easing only");
    easingFunc = $.Velocity.Easings[easing];
    totalWeight = sequence.reduce((function(sum, item) {
      return sum + VelocityEasingUtils._getDuration(item);
    }), 0);
    if (duration == null) {
      duration = totalWeight;
    }
    cumulativeWeight = 0;
    return sequence.map(function(item, i) {
      var customEasing, customEasingName, fromDuration, fromProgress, itemDuration, newOptions, options, optionsEasing, optionsEasingName, optionsProgressCallback, toDuration, toProgress, weight;
      options = item.o || item.options;
      console.assert(!(options != null ? options.sequenceQueue : void 0), 'Sequential animations only');
      weight = VelocityEasingUtils._getDuration(item);
      fromProgress = cumulativeWeight / totalWeight;
      toProgress = (cumulativeWeight + weight) / totalWeight;
      cumulativeWeight += weight;
      fromDuration = VelocityEasingUtils._inverseEasing(easingFunc)(fromProgress);
      toDuration = VelocityEasingUtils._inverseEasing(easingFunc)(toProgress);
      itemDuration = duration * (toDuration - fromDuration);
      customEasingName = easing + "-" + fromDuration + "-" + toDuration;
      customEasing = VelocityEasingUtils._renormalizedEasing(easingFunc, fromDuration, toDuration);
      optionsEasingName = options != null ? options.easing : void 0;
      console.assert(!optionsEasingName || optionsEasingName in $.Velocity.Easings, "String easing only");
      optionsEasing = $.Velocity.Easings[optionsEasingName];
      if (optionsEasing) {
        customEasingName = "${optionsEasingName}-" + customEasingName;
        $.Velocity.Easings[customEasingName] = VelocityEasingUtils._composeEasing(customEasing, optionsEasing);
      } else {
        $.Velocity.Easings[customEasingName] = customEasing;
      }
      optionsProgressCallback = options != null ? options.progress : void 0;
      newOptions = {
        easing: customEasingName,
        duration: itemDuration,
        progress: !debugCanvas ? optionsProgressCallback : function() {
          var e, percent, rest;
          e = arguments[0], percent = arguments[1], rest = 3 <= arguments.length ? slice.call(arguments, 2) : [];
          return window.requestAnimationFrame(function() {
            VelocityEasingUtils.drawEasingGraph(debugCanvas, easingFunc, fromDuration + (toDuration - fromDuration) * percent, fromDuration, toDuration, ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'][i % 7]);
            return typeof optionsProgressCallback === "function" ? optionsProgressCallback.apply(null, [e, percent].concat(slice.call(rest))) : void 0;
          });
        }
      };
      if (item.options) {
        item.options = $.extend({}, item.options, newOptions);
      } else {
        item.o = $.extend({}, item.o, newOptions);
      }
      return item;
    });
  },
  drawEasingGraph: function(canvas, easing, currentDuration, fromDuration, toDuration, color) {
    var arrowSize, context, currentProgress, fromProgress, height, j, lineHeight, margin, ref, toProgress, width, x;
    if (currentDuration == null) {
      currentDuration = null;
    }
    if (fromDuration == null) {
      fromDuration = 0;
    }
    if (toDuration == null) {
      toDuration = 1;
    }
    if (color == null) {
      color = 'black';
    }
    if (typeof easing === 'string') {
      easing = $.Velocity.Easings[easing];
    }
    canvas = $(canvas)[0];
    context = canvas.getContext('2d');
    margin = 30;
    width = canvas.width - 2 * margin;
    height = canvas.height - 2 * margin;
    currentProgress = easing(currentDuration);
    fromProgress = easing(fromDuration);
    toProgress = easing(toDuration);
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.strokeStyle = '#636363';
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo(margin, margin + height - height * fromProgress);
    context.lineTo(margin + width * fromDuration, margin + height - height * fromProgress);
    context.stroke();
    context.beginPath();
    context.moveTo(margin, margin + height - height * toProgress);
    context.lineTo(margin + width * toDuration, margin + height - height * toProgress);
    context.stroke();
    context.strokeStyle = '#eee';
    context.lineWidth = 1;
    context.beginPath();
    context.moveTo(margin + width * fromDuration, margin + height);
    context.lineTo(margin + width * fromDuration, margin + height - height * fromProgress);
    context.stroke();
    context.beginPath();
    context.moveTo(margin + width * toDuration, margin + height);
    context.lineTo(margin + width * toDuration, margin + height - height * toProgress);
    context.stroke();
    context.strokeStyle = 'black';
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(margin, margin);
    context.lineTo(margin, margin + height);
    context.lineTo(margin + width, margin + height);
    context.stroke();
    lineHeight = 12;
    context.font = lineHeight + "px Arial";
    context.fillStyle = '#636363';
    context.textAlign = 'center';
    context.save();
    context.translate(margin + width / 2, margin + height + margin / 2);
    context.fillText('Time', 0, lineHeight / 2);
    context.restore();
    context.save();
    context.translate(margin / 2, margin + height / 2);
    context.rotate(-Math.PI / 2);
    context.fillText('Progress', 0, lineHeight / 2);
    context.restore();
    if (currentDuration != null) {
      arrowSize = 6;
      context.fillStyle = '#636363';
      context.beginPath();
      context.moveTo(margin + width * currentDuration, margin + height);
      context.lineTo(margin + width * currentDuration - 3, margin + height + arrowSize);
      context.lineTo(margin + width * currentDuration + 3, margin + height + arrowSize);
      context.fill();
    }
    context.strokeStyle = 'black';
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(margin, margin + height);
    for (x = j = 0, ref = width; 0 <= ref ? j <= ref : j >= ref; x = 0 <= ref ? ++j : --j) {
      context.lineTo(margin + x, margin + height - height * easing(x / width));
      if (x === Math.round(width * fromDuration)) {
        context.stroke();
        context.strokeStyle = color;
        context.lineWidth = 5;
        context.beginPath();
        context.moveTo(margin + x, margin + height - height * easing(x / width));
      }
      if (x === Math.round(width * currentDuration)) {
        context.stroke();
        context.strokeStyle = 'black';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(margin + x, margin + height - height * easing(x / width));
      }
    }
    return context.stroke();
  }
};
